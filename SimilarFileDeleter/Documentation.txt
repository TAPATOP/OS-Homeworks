--------Описанието е на дъното------------
За пускане: В случай, че скриптът се намира в текущата папка, се пуска така:
"./script <аргумент>", където <аргумент> е името на папката, над която
искаме да се извършат операциите.
------------------------------------------
#!/bin/bash

ORIG=$IFS
IFS=$'\0'
FLAG=0
if [ $# -eq 1 ]; then
  SPATH="./$1"
  ARRAY=()
  while read -r -d '' FILE; do
    ARRAY+=($FILE)
  done< <(find "$SPATH" -type f -print0)

  IFS=$ORIG

  LIMIT=${#ARRAY[@]}
  COUNT=$LIMIT

  for i in `seq 0 $(($LIMIT-1))`;
  do
    if [ -f "${ARRAY[$i]}" ]; then
      for j in `seq $(($i+1)) $(($LIMIT-1))`;
      do
        if [ -f "${ARRAY[$j]}" ]; then
          cmp "${ARRAY[$i]}" "${ARRAY[$j]}" >/dev/null
          if [ $? -eq 0 ]; then
            rm "${ARRAY[$j]}"
            COUNT=$(($COUNT-1))
            FLAG=1
          fi
        fi
      done
      if [ $FLAG -eq 1 ]; then
        rm "${ARRAY[$i]}"
        FLAG=0
      fi
    fi
  done
  echo $COUNT
else
  echo pls gib one argument
fi

------------Описание----------------
ORIG=$IFS
IFS=$'\0'

IFS(Internal Field Separator) се задава на символа "край на низ"( използва се по- късно),
но стойността му се запазва в $ORIG, за да може да се възстанови безопасно.
---
if [ $# -eq 1 ]; then
  SPATH="./$1"

Проверява се дали има подаден точно 1 аргумент аргумент и се създава
пътят до целевата папка.
---
  ARRAY=()
  while read -r -d '' FILE; do
    ARRAY+=($FILE)
  done< <(find "$SPATH" -type f -print0)

(find "$SPATH" -type f -print0) се подава на (while read -r -d '' FILE) с цел
да се избегне употребата на pipe( който би създал subshell, чиято работа
върху $ARRAY не би била запазена).
(find "$SPATH" -type f -print0) открива всички файлове и подава имената им разделени
с '/0'

---
  IFS=$ORIG

Стойността на IFS се възстановява, понеже for го използва
---
  for i in `seq 0 $(($LIMIT-1))`;
  do
    if [ -f "${ARRAY[$i]}" ]; then
      for j in `seq $(($i+1)) $(($LIMIT-1))`;
      do
        if [ -f "${ARRAY[$j]}" ]; then

Пуска се двоен цикъл, който селектира индексите на файловете, над които ще
се работи. Интервалът на втория цикъл е [ $(($i+1)) ; $(($LIMIT-1)) ] за да
се избегне сравняване на едни и същи файлове повече от веднъж.
Също така се проверява дали файловете със съответите имена съществуват, 
понеже може да са били изтрити в някоя от итерациите от харддиска,
но имената им все още да са в масива
---
          cmp "${ARRAY[$i]}" "${ARRAY[$j]}" >/dev/null
          if [ $? -eq 0 ]; then
            rm "${ARRAY[$j]}"
            COUNT=$(($COUNT-1))
            FLAG=1
          fi
Сравняват се файловете. Използвам cmp, а не diff, защото се предполага,
че cmp спира сравнението при първия байт разлика. По принцип cmp съобщава
на стандартния изход за открити разлики и за това се налага този канал да
бъде пренасочен към /dev/null. При открита разлика се задава флаг, който
сигнализира, че файлът, с който проверяваме, трябва да се изтрие, когато бъде
сравнен с всички налични файлове. Също така, COUNT първоначално е равен на броя на
елементи в $ARRAY, но при всеки изтрит сравнен файл той се намаля с едно.
---
      if [ $FLAG -eq 1 ]; then
        rm "${ARRAY[$i]}"
        FLAG=0
      fi
При зададен флаг се изтрива файлът, с който сме проверявали до сега и флагът
се рестартира с цел да не затрием и следващия файл без да се е наложило. COUNT 
не се намаля, понеже текущият файл се брои за "уникален".
---
else
  echo pls gib one argument
fi
Потребителят бива уведомен при подаване на повече от 1 аргумент на скрипта.