Скриптът се изпълнява по стандартния начин- извиква се и му се дава точно един
аргумент(папка). При липса на аргумент извежда.... предупредителен текст. Частите,
отговорни за промяната на EXIF, са изкоментирани, с цел да не променят резултата
от командата за проверка на работата на скрипта.
====================================================================================
#!/bin/bash

if [ $# -ne 1 ]; then
  echo "Hi, I am an Albanian virus but because of poor technology in my country unfortunately I am not able to harm your computer. Please be so kind to delete one of your important files yourself and then forward me to other users. Many thanks for your cooperation! Best regards, Albanian virus
P.S: Try giving me exactly one argument next time"
  exit 1
fi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Проверява дали е подаден точно един аргумент за папка
===================================================================================

#dpkg -l | grep exiftool>/dev/null
#if [ $? -eq 1 ]; then
#  echo If you want to have the full functionality, install exiftool, please.
#else
#  STATUS=1
#fi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Проверява дали машината има инсталиран exiftool, който е отговорен за вкарването на
координатите на снимката в EXIF-а на изображението. Задава флаг STATUS=1, ако е
инсталирана(по- късно се използва) или извежда информиращо съобщение, ако не е.
===================================================================================
for foldr in `find "$1" -type d | sed '1d'`; do
  if [[ -e "$foldr.log" ]]; then
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Извежда всички папки и проверява дали файл с името на папката и разширение .log
съществува.
===================================================================================

    for FILE in `ls ./"$foldr" -lctr | grep ".jpg" | tr -s " " | cut -f 9 -d " "`;do
      FILES+=($FILE)
    done
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Вкарва имената на всички ".jpg" файлове в "$foldr" в масив, подредени по "ctime"
===================================================================================
    while read LINE; do
      [...]
    done<$foldr.log
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Чете от файла със съответното име. Отдолу е описано какво се случва в [...]
===================================================================================
      VAR=`printf "%d" "'$LINE"`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Взима ASCII кода на съответната "$LINE". Ако във файла има нов ред, ще се прочете
като "0"( вероятно по вина на IFS). В дъното на цикъла се използва за обозначаване,
че е ред да се чете запис за нов файл.
===================================================================================
      CNTR=$(($CNTR+1))
      if [ $CNTR -lt 3 ]; then
        if [ $CNTR -eq 1 ]; then
	  DATE=$(echo $LINE | cut -f 1 -d ' ')
	  DDATE=$(date --date=@$DATE -Is | cut -f 1,2 -d ':' | tr -d ':')
	  COORDS=$(echo $LINE | cut -f 2 -d ' ')
	  LONGITUDE=$(echo $COORDS | cut -f 1 -d ',')
	  LATITUDE=$(echo $COORDS | cut -f 2 -d ',')
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Ако "$CNTR" е 0, значи току- що е започнал прочит на нов запис, следователно
"$LINE" съдържа дата и координати. Първо се извлича "$DATE", която е във формат Unix
time, която се преобразува в "ISO 8601" формат( като се изрязват ненужните данни), 
записани като "$DDATE". Извличат се и "$LONGITUDE" и "$LATITUDE"( предполагаме, че 
във файла първо е записан "$LONGTITUDE" и след него $LATITUDE").
===================================================================================
	else
	  TRANS=$(echo $LINE | tr [:upper:] [:lower:] | tr " " "_" | sed 's/[^[:alnum:]|_]//g')
          NEWNAME="$DDATE"_"$TRANS".jpg
	  mv "$foldr"/"${FILES[$INDEX]}" "$foldr"/"$NEWNAME"
	  INDEX=$((INDEX+1))
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
В "$TRANS" се записва "$LINE" с малки букви, след което всички интервали се
трансформират в долни черти и всичко, различно от цифра, буква или долна черта,
се изтрива. Накрая се образува новото име, файлът се премества и "$INDEX" се
увеличава, с цел "${FILES[$INDEX]}" да сочи към името на следващия файл.
===================================================================================
#	  if [ $STATUS -eq 1 ]; then
#	    exiftool -GPSLongitude="$LONGITUDE"  -GPSLatitude="$LATITUDE" "$foldr"/"$NEWNAME"
# 	  fi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Ако "$STATUS" e бил зададен като "1" в началото на програмата, се променя EXIF-a
на целевия ".jpg" файл.
===================================================================================
	fi
      continue
      fi
      
      if [[ "$VAR" -eq 0 ]]; then
        CNTR=0
      fi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Ако стойността на "$VAR" e 0, то сме стигнали до "нов ред" и започваме да четем
нов запис. Ако не е 0, то текущият ред се игнорира.
===================================================================================
  fi
done
